一、关于指针

1.指针常量、常量指针
int* const a;   //指针常量  
const int* a;   //常量指针
int const * a;  //常量指针
常量指针，首先他是一个指针，所以他是指向常量的指针
指针常量，首先他是一个常量，所以他是一个常量的指针

2.二维数组的指针问题
char a[3][4] = { "123","abc","456" };

char* p = a[0];
cout << *p << endl;

char (*q)[4];
q = a;
cout << *q << endl;
可见，p是一个指向char类型的指针，而q是指向一个char[4]类型的指针，分别用作不同的偏移


二、关于stl容器

1.vector迭代器的重载运算符
迭代器iterator没有重载左移，右移运算符

2.stack容器
有push、pop、top函数，pop函数没有返回值，只能有top函数取出栈最上面的值（即将被pop的值）

三、关于系统调用

1.fork()
fork()系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回。
如果返回是0，则是子进程，如果返回值>0，则是父进程（返回值是子进程的pid），这是众为周知的。

四、父类子类那些事
如果基类的析构函数不是虚函数，那么，像这种定义一个基类的指针，指向一个派生类的对象，当你delete这个基类的指针时，它仅调用基类的析构函数，并不调用派生类的析构函数。
如果基类的析构函数是虚函数，delete基类的指针时，不仅会调用基类的析构函数，还会调用派生类的析构函数。
